<section class="shared-content" style="width: calc(100% - 160px);float: left;">
  <header>
    <nav class="my-nav">
      <a class="icon-wrapper" (click)="clickOpen(1)"><span [ngClass]="{'current-menu':currentTab===1}">主要描述</span></a>
      <a class="icon-wrapper" (click)="clickOpen(2)"><span [ngClass]="{'current-menu':currentTab===2}">Subject()</span></a>
      <a class="icon-wrapper" (click)="clickOpen(3)"><span [ngClass]="{'current-menu':currentTab===3}">BehaviorSubject(value)</span></a>
      <a class="icon-wrapper" (click)="clickOpen(4)"><span [ngClass]="{'current-menu':currentTab===4}">ReplaySubject(n)</span></a>
      <a class="icon-wrapper" (click)="clickOpen(5)"><span [ngClass]="{'current-menu':currentTab===5}">AsyncSubject()</span></a>
    </nav>
  </header>
  <fieldset *ngIf="currentTab ===1" class="margin-top-20 padding-20">
    <p>观察者模式有四大因素：观察者-注册--发布者-广播</p>
    <h3>针对不同的场景一共有四种类型的Subject。</h3>
    <legend>简单介绍</legend>
    <article>
      <p>Subject 是一个神奇的对象，它可以是一个Observable同时也可以是一个Observer：
        它作为连接这两个世界的一座桥梁。一个Subject可以订阅一个Observable，就像一个观察者，
        并且它可以发射新的数据，或者传递它接受到的数据，就像一个Observable。很明显，作为一个Observable，
        观察者们或者其它Subject都可以订阅它。</p>
      <p>一旦Subject订阅了Observable，它将会触发Observable开始发射。
        如果原始的Observable是“冷”的，这将会对订阅一个“热”的Observable变量产生影响。</p>
        <h3>使用方式</h3>
        <ol>
          <li>定义发布者：let Observable = new Subject()</li>
          <li>{{bb}}</li>
          <li>注册：Observable.subscribe(Observer)</li>
          <li>广播：Observable.next('Hello!')</li>
        </ol>
    </article>
  </fieldset>
  <fieldset *ngIf="currentTab===2" class="margin-top-20 padding-20">
    <legend>Subject 简介</legend>
    <article>
      <p>当有新消息时，Subject 会对内部的 observers 列表进行组播 (multicast)</p>
      <p>
        Subject只会把在订阅发生的时间点之后来自原始Observable的数据发射给观察者。
        需要注意的是，PublishSubject可能会一创建完成就立刻开始发射数据（除非你可以阻止它发生）
        ，因此这里有一个风险：在Subject被创建后到有观察者订阅它之前这个时间段内，
        一个或多个数据可能会丢失。如果要确保来自原始Observable的所有数据都被分发，
        你需要这样做：或者使用Create创建那个Observable以便手动给它引入“冷”Observable的
        行为（当所有观察者都已经订阅时才开始发射数据），或者改用ReplaySubject。
      </p>
      <div class="img-span img1"></div>
      <p>如果原始的Observable因为发生了一个错误而终止，BehaviorSubject将不会发射任何数据，
        只是简单的向前传递这个错误通知。</p>
      <div class="img-span img2"></div>
    </article>
  </fieldset>
  <fieldset *ngIf="currentTab===3" class="margin-top-20 padding-20">
    <legend>BehaviorSubject 简介</legend>
    <article>
      <p>
        当观察者订阅BehaviorSubject时，它开始发射原始Observable最近发射的数据
        （如果此时还没有收到任何数据，它会发射一个默认值），
        然后继续发射其它任何来自原始Observable的数据。
      </p>
      <div class="img-span img3"></div>
      <p>然而，如果原始的Observable因为发生了一个错误而终止，
        BehaviorSubject将不会发射任何数据，只是简单的向前传递这个错误通知。</p>
      <div class="img-span img4"></div>
    </article>
  </fieldset>

  <fieldset *ngIf="currentTab===4" class="margin-top-20 padding-20">
    <legend>ReplaySubject 简介</legend>
    <article>
      <p>
        ReplaySubject会发射所有来自原始Observable的数据给观察者，无论它们是何时
        订阅的。也有其它版本的ReplaySubject，在重放缓存增长到一定大小的时候或过了
        一段时间后会丢弃旧的数据（原始Observable发射的）。</p>
      <p>如果你把ReplaySubject当作一个观察者使用，注意不要从多个线程中调用
        它的onNext方法（包括其它的on系列方法），这可能导致同时（非顺序）调用，
        这会违反Observable协议，给Subject的结果增加了不确定性。</p>
      <div class="img-span img5"></div>
    </article>
  </fieldset>
  <fieldset *ngIf="currentTab===5" class="margin-top-20 padding-20">
    <legend>AsyncSubject 简介</legend>
    <article>
      <p>
        一个AsyncSubject只在原始Observable完成后，发射来自原始Observable的最后一个值。
        （如果原始Observable没有发射任何值，AsyncObject也不发射任何值）它会把这最后一个值发射给任何后续的观察者。</p>
      <div class="img-span img6"></div>
      <p>然而，如果原始的Observable因为发生了错误而终止，AsyncSubject将不会发射
        任何数据，只是简单的向前传递这个错误通知。</p>
      <div class="img-span img7"></div>
    </article>
  </fieldset>
</section>
